## 비대칭키/ 공개키(PKC) 암호
- 두 개의 키를 사용: 메시지는 공개키(public key)로 암호화되고 개인키(private key)로 복호화 함
- 계산의 양은 대칭키보다 훨씬 많아서 사용하는데 장애물이 됨
- PKC의 절차는 대칭키 암호보다 더 간단하거나 효율적이지 않음
- 키 분배를 위해서는 공개키 구조(PKI)가 필요
- PKC가 해결하는 문제들: 기밀성, 전자서명은 무결성과 인증과 부인 봉쇄를 제공
  
## 대칭키 vs 비대칭키

|  | 대칭키: 비밀키 | 비대칭키: 공개키/개인키 |
|--|-------------- | -----------------------|
|장점|속도가 빠름, 공개키 구조(PKI)가 필요 없음| 서명 (부인 봉쇄), 공유된 비밀키가 필요 없음
|차이점|공유하는 비밀키 필요, 대칭키를 어떻게 설정의 문제 있음|믿을 수 있는 공개키 필요, 암호화 비효율적
|종류|DES, ARS|Knapsack, RSA...

#### DES (Data Encryption Standard)
- 64비트 블록 암호 알고리즘 (56비트 + 8비트(패리티))
- Feistel 암호방식 사용: 치환과 순열을 번갈아 수행하는 암호방식 (혼돈함수와 확산함수 번갈아 수행)
- 대칭키 암호를 설계할 때 치환과 순열연산을 포함시켜서 한 개의 라운드를 구성
- round 수: 16
- 복호화는 암호화의 역순
- 처리단계
```
1) 초기 순열 단계: 평문 64bit를 받아 미리 정해놓은 초기 순열 테이블을 이용하여 전치를 시킨다.
2) 16라운드 반복
3) 좌우 교환단계
4) 역초기 순열 단계
```

#### 일방향 해시함수
- 예) 주어진 수 / 23 = 목의 소수점 이하 7~10자리 수: 역으로 주어진 수를 계산할 수 없음
- 입력(메시지)과 출력(해시 값)이 1개씩 있음


#### 일방향 해시함수의 성질
1. 임의의 길이 메시지로부터 고정 길이의 해시값을 계산
2. 해시값을 고속으로 계산할 수 있음
3. 메시지가 다르면 해시값도 다름
4. 일방향성을 가짐

> #### 충돌
> 2개의 다른 메시지가 같은 해시값을 갖는 것 (두 개의 서로 다른 입력에 대해 동일한 출력 값)
> - 무결성 확인에 사용하기 위해서는 충돌이 발견되어서는 안 됨
> - 충돌 내성(충돌을 발견하기 어려운 성질)을 가질 필요가 있음
> ```
> 1) 약한 충돌 내성: 그 해시값을 갖는 다른 메시지를 발견해내는 것이 매우 곤란하다는 성질
> 2) 강한 충돌 내성: 해시값이 일치할 것 같은 다른 2개의 메시지를 발견해내는 것이 곤란하다는 성질
> ```  
> 
> #### 일방향 해시함수에 대한 공격
> 1) 전사 공격: 메시지 값을 조금씩 변화시켜 그때마다 해시값을 구하고 원래 문장과 같은 해시값을 가진 메시지로 변경
>   - 일방향 해시함수의 약한 충돌 내성을 깨고자 하는 공격
> 2) 생일 공격: 같은 해시값을 생성하는 메시지를 2개 구하는 공격
> - 동일한 해시값을 가진 메시지로 속임, N이 길수록 메모리양이 많이 필요하여 생일 공격 어려움
> - 일방향 해시 수의 강한 충돌 내성을 깨고자 하는 공격
> 
> #### 일방향 해시함수로 해결할 수 없는 문제
> - 일방향 해시함수는 수정 또는 변경을 검출할 수 있지만 거짓 행세를 검출하는 것은 못 함
> ⇒ 따라서 무결성 외에 인증 절차 필요 (인증 기술: 메시지 인증 코드와 디지털 서명)  

## Public Key

#### Knapsack
  - 일반적인 Knapsack (GK)보다 superincreasing Knapsack (SIK) 문제는 풀기 쉬움
  - SKI: 가중치는 모든 이전의 가중치의 합보다 큼, 가장 큰 가중치부터 가장 작은 가중치 순서대로 비교 
  - Knapsack 암호 체계
    ① SIK를 생성
    ② SIK를 GK로 변환
    : 공개키(GK), 개인키(SIK와 conversion factors) 
  - Knapsack 암호화 예
   
#### RSA
  - p, q: 두 개의 큰 소수
  - N = pq
  - (p-1)(q-1)와 서로 소수인 e
  - ed = 1 mod (p-1)(q-1)인 d
  = 공개키(N, e), 개인키(d)
  ⇒ 메시지 M의 암호화: C = Me mod N
  ⇒ 암호문 C의 복호화: M = Cd mod N
  - N을 소인수 분해할 0수 있다면 RSA를 깰 수 있음
  - RSA 사용 예
   
#### Diffie-Hellman key Exchange: 키 교환 알고리즘
  - 대칭키를 공유하는데 사용하며, 암호화나 서명을 위한 것은 아님
  - 안전성은 discrete log problem에 달려있음
  - 공개된 값: 큰 소수 p, generator g
  - gk mod p = x
  - x, q, p가 주어졌을 때 k를 구함
  
 ```
 *공개: g, p/ 비밀값: Alice 비밀값 a, Bob 비밀값 b 일 때, 
  
 ⇒ 비밀 키(값)를 대칭키로 사용함
 *man-in-the-middle (MiM) 공격: Diffie-Hellman에서는 MiM 공격이 가능함
 
 ⇒ 공격 막기 위한 해법
 1) 교환하는 값을 대칭키로 암호화하여 보냄
 2) 교환하는 값을 공개키로 암호화하여 보냄
 3) 교환하는 값을 개인키로 서명
```

#### 공개키 구조(PKI: Public key infra structure)
  - 공개키 암호 방식을 안전하게 사용하기 위해 필요한 모든 요소로 구성, 공개키 암호화나 전자서명이 안전하게 사용되기 위해서는 키의 생성과 인증, 분배와 안전한 관리를 위한 믿을 수 있는 체계
  - 인증서의 발급, 사용 및 취소와 관련 서비스를 통해 기밀성, 무결성, 접근제어, 인증, 부인방지의 보안서비스를 제공하며 인증기관(CA), 사용자, 저장소 등의 요소로 구성

  - 암호화와 복호화키로 구성된 공개키를 이용하여 송수신 데이터를 암호화하고 디지털인증서(전자서명)를 통해 사용자를 인증하는 시스템

  - 공개키를 이용하여 송수신 데이터를 암호화하고 디지털 인증서를 통해 사용자를 인증하는 시스템으로, 공개키 암호 알고리즘을 안전하게 사용하기 위해 필요한 서비스를 제공하는 기반 구조이다. 안전성과 투명성을 위해서 제3의 신뢰받는 기관이 디지털 인증서를 발급한다. 인증서가 순환하는 트러스트 모델을 가지고 있다.

  - PKI를 개발하게 된 주요한 목적: 안전하고, 편리하고, 효율적으로 공개키 획득
  - PKI가 제공하는 서비스: 기밀성, 무결성, 인증, 부인방지, 접근통제

  - PKI 구성 요소
    이용자: PKI를 이용하는 사람
    인증기관 : 인증서를 발행하는 사람
    저장소: 인증서를 보관하고 있는 데이터베이스
